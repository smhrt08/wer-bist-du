<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>wer bist du</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: system-ui, sans-serif;
      background: #f1f5f9;
      padding: 2rem;
    }
    .container {
      max-width: 1400px;
      margin: 0 auto;
    }
    .header {
      text-align: center;
      margin-bottom: 2rem;
    }
    .header h1 {
      font-size: 2rem;
      font-weight: 700;
      color: #1e293b;
    }
    .header h3 {
      margin: 0 0 15px 0;
      color: #64748b;
    }

    .video-row {
      display: flex;
      gap: 1.5rem;
      margin-bottom: 1.5rem;
    }

    .card {
      flex: 1;
      background: white;
      border-radius: 1rem;
      box-shadow: 0 4px 10px rgba(0,0,0,0.08);
      padding: 1rem;
    }

    .card h3 {
      margin-bottom: 0.5rem;
      color: #1e3a8a;
      font-size: 1.1rem;
    }

    .video-container {
      position: relative;
      background: #0f172a;
      border-radius: 0.75rem;
      overflow: hidden;
      aspect-ratio: 16/9;
    }

    video, canvas {
      width: 100%;
      height: 100%;
      object-fit: contain;
    }

    .hidden {
      display: none !important;
    }

    .controls {
      margin-top: 1rem;
      display: flex;
      gap: 1rem;
      align-items: center;
    }

    .control-group {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .control-label {
      font-size: 0.875rem;
      color: #334155;
    }

    .toggle {
      position: relative;
      width: 3rem;
      height: 1.5rem;
      background: #cbd5e1;
      border-radius: 1rem;
      cursor: pointer;
      transition: background 0.3s;
    }

    .toggle.disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .toggle.active {
      background: #2563eb;
    }

    .toggle-slider {
      position: absolute;
      top: 0.2rem;
      left: 0.2rem;
      width: 1.1rem;
      height: 1.1rem;
      background: white;
      border-radius: 50%;
      transition: transform 0.3s;
    }

    .toggle.active .toggle-slider {
      transform: translateX(1.4rem);
    }

    .debug-panel {
      background: white;
      border-radius: 1rem;
      box-shadow: 0 4px 10px rgba(0,0,0,0.08);
      padding: 1rem;
    }

    .debug-panel h2 {
      color: #1e293b;
      font-size: 1.2rem;
      margin-bottom: 0.5rem;
    }

    .debug-log {
      height: 18rem;
      overflow-y: auto;
      background: #f8fafc;
      border: 1px solid #e2e8f0;
      border-radius: 0.5rem;
      padding: 0.5rem;
      font-family: monospace;
      font-size: 0.8rem;
      color: #334155;
    }

    button {
      /* background-color: #007bff; */
      font-family: "Open Sans", sans-serif;
      font-size: 16px;
      letter-spacing: 2px;
      text-decoration: none;
      text-transform: uppercase;
      color: #000;
      cursor: pointer;
      border: 3px solid;
      padding: 0.25em 0.5em;
      box-shadow: 1px 1px 0px 0px, 2px 2px 0px 0px, 3px 3px 0px 0px, 4px 4px 0px 0px, 5px 5px 0px 0px;
      position: relative;
      user-select: none;
      -webkit-user-select: none;
      touch-action: manipulation;
    }
    .button:active {
      box-shadow: 0px 0px 0px 0px;
      top: 5px;
      left: 5px;
    }
    @media (min-width: 768px) {
      .button {
        padding: 0.25em 0.75em;
      }
    }

    /* button:hover:not(:disabled) {
      background-color: #0056b3;
    }

    button:disabled {
      background-color: #ccc;
      cursor: not-allowed;
    } */

    .toast {
      visibility: hidden;
      display: flex;
      width: 348px;
      min-height: 44px;
      flex-direction: row;
      align-items: center;
      gap: 8px;
      border-radius: 8px;
      background: #F9F9F9;
      box-shadow: 0 0 8px 0 rgba(22, 51, 95, 0.10);
      color: #333;
      text-align: left;
      padding: 12px 16px;
      position: fixed;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 1000;
      transition: visibility 0.5s, opacity 0.5s;
      opacity: 0;
    }

    .toast.show {
      visibility: visible;
      opacity: 1;
    }

    #faceToast {
      border: 1px solid #F0775C;
    }

    @media (max-width: 768px) {
      .video-row {
        flex-direction: column;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>wer bist du</h1>
      <h3>v4.009</h3>
      <button id="startBtn">Start Camera</button>
    </div>

    <div class="video-row">
      <div class="card">
        <!-- <h3>Face Detection View</h3> -->
        <div class="video-container">
          <video id="videoLeft" autoplay muted playsinline></video>
          <canvas id="canvasLeft" class="hidden"></canvas>
        </div>
      </div>

      <div class="card">
        <!-- <h3>Background Isolation View</h3> -->
        <div class="video-container">
          <video id="videoRight" autoplay muted playsinline></video>
          <canvas id="canvasRight" class="hidden"></canvas>
        </div>
        <div class="controls">
          <div class="control-group">
            <span class="control-label">Virtual BG</span>
            <div id="bgToggle" class="toggle disabled">
              <div class="toggle-slider"></div>
            </div>
          </div>
          <div class="control-group">
            <span class="control-label">Ghost Mode</span>
            <div id="ghostToggle" class="toggle disabled">
              <div class="toggle-slider"></div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="debug-panel">
      <h2>Debug Log</h2>
      <div id="debugLog" class="debug-log"></div>
    </div>
  </div>

  <div id="faceToast" class="toast">
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none">
      <path d="M12 8V12M12 16H12.01M22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12Z" stroke="#D42802" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
    </svg>
    Multiple faces detected in the background!
  </div>

  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/selfie_segmentation.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_detection/face_detection.js"></script>

  <script>
    const videoLeft = document.getElementById('videoLeft');
    const videoRight = document.getElementById('videoRight');
    const canvasLeft = document.getElementById('canvasLeft');
    const canvasRight = document.getElementById('canvasRight');
    const startBtn = document.getElementById('startBtn');
    const bgToggle = document.getElementById('bgToggle');
    const ghostToggle = document.getElementById('ghostToggle');
    const debugLog = document.getElementById('debugLog');
    const faceToast = document.getElementById('faceToast');

    let stream = null;
    let virtualBgEnabled = false;
    let ghostModeEnabled = false;
    let selfieSegmentation = null;
    let faceDetection = null;
    let camera = null;
    let latestFaces = [];
    let frameCount = 0;

    // Persistent mask system
    const MASK_WIDTH = 320;
    const MASK_HEIGHT = 180;
    let persistentMask = null;
    let previousFrameData = null;
    let primaryFaceBox = null;

    const MASK_STRENGTHEN_RATE = 0.3;
    const MASK_DECAY_RATE = 0.02;
    const MOTION_THRESHOLD = 15;
    const FACE_REGION_SCALE = 3.5;

    function log(msg) {
      const timestamp = new Date().toLocaleTimeString();
      debugLog.innerHTML += `[${timestamp}] ${msg}<br>`;
      debugLog.scrollTop = debugLog.scrollHeight;
      console.log(msg);
    }

    function showToast(toast) {
      toast.className = "toast show";
      setTimeout(() => { toast.className = "toast"; }, 5000);
    }

    async function startCamera() {
      try {
        startBtn.disabled = true;
        startBtn.textContent = 'Initializing...';
        log('Requesting camera...');

        stream = await navigator.mediaDevices.getUserMedia({
          video: { width: 1280, height: 720, facingMode: 'user' },
          audio: false
        });

        videoLeft.srcObject = stream;
        videoRight.srcObject = stream;

        await videoLeft.play();
        await videoRight.play();

        log('✓ Camera started on both feeds');
        startBtn.textContent = 'Camera Active';
        bgToggle.classList.remove('disabled');

        await initMediaPipe();

      } catch (err) {
        log('Camera error: ' + err.message);
        startBtn.disabled = false;
        startBtn.textContent = 'Start Camera';
      }
    }

    async function initMediaPipe() {
      log('Initializing MediaPipe...');

      try {
        // Initialize selfie segmentation
        selfieSegmentation = new SelfieSegmentation({
          locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/${f}`
        });
        selfieSegmentation.setOptions({
          modelSelection: 1,
          selfieMode: false
        });
        selfieSegmentation.onResults(onSegmentationResults);

        // Initialize face detection
        faceDetection = new FaceDetection({
          locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_detection/${f}`
        });
        faceDetection.setOptions({
          model: 'short',
          minDetectionConfidence: 0.5
        });
        faceDetection.onResults(onFaceResults);

        // Initialize persistent mask
        persistentMask = new Float32Array(MASK_WIDTH * MASK_HEIGHT);

        // Start camera processing - face detection always runs
        camera = new Camera(videoRight, {
          onFrame: async () => {
            await faceDetection.send({ image: videoLeft });
            if (virtualBgEnabled) {
              await selfieSegmentation.send({ image: videoRight });
            }
          },
          width: 1280,
          height: 720
        });

        await camera.start();
        log('✓ MediaPipe initialized');
        log('✓ Face detection running continuously');
        log('✓ Persistent mask system ready');

      } catch (err) {
        log(`MediaPipe error: ${err.message}`);
      }
    }

    function onFaceResults(results) {
      if (!results.detections || results.detections.length === 0) {
        latestFaces = [];
        primaryFaceBox = null;
        return;
      }

      latestFaces = results.detections;

      // Draw faces on left canvas
      const ctx = canvasLeft.getContext('2d');
      canvasLeft.width = videoLeft.videoWidth;
      canvasLeft.height = videoLeft.videoHeight;

      ctx.clearRect(0, 0, canvasLeft.width, canvasLeft.height);
      ctx.drawImage(videoLeft, 0, 0);

      // Pick primary face (largest + most central)
      const videoW = videoLeft.videoWidth;
      const videoH = videoLeft.videoHeight;
      const centerX = videoW / 2;
      const centerY = videoH / 2;

      let bestFace = null;
      let bestScore = -1;

      for (const detection of results.detections) {
        const box = detection.boundingBox;
        const fx = box.xCenter * videoW;
        const fy = box.yCenter * videoH;
        const fw = box.width * videoW;
        const fh = box.height * videoH;

        const distFromCenter = Math.sqrt(
          Math.pow(fx - centerX, 2) + Math.pow(fy - centerY, 2)
        );

        const area = fw * fh;
        const score = area / (1 + distFromCenter * 0.001);

        if (score > bestScore) {
          bestScore = score;
          bestFace = { x: fx, y: fy, width: fw, height: fh };
        }

        // Draw all face boxes
        ctx.strokeStyle = '#00ff00';
        ctx.lineWidth = 2;
        ctx.strokeRect(
          fx - fw / 2,
          fy - fh / 2,
          fw,
          fh
        );
      }

      // Draw primary face in different color
      if (bestFace) {
        primaryFaceBox = bestFace;
        ctx.strokeStyle = '#00bfff';
        ctx.lineWidth = 3;
        ctx.strokeRect(
          bestFace.x - bestFace.width / 2,
          bestFace.y - bestFace.height / 2,
          bestFace.width,
          bestFace.height
        );
      }

      // Show left canvas with face boxes
      canvasLeft.classList.remove('hidden');
      videoLeft.classList.add('hidden');

      // Alert on multiple faces
      if (results.detections.length > 1 && Math.random() < 0.1) {
        showToast(faceToast);
        log(`⚠️ ${results.detections.length} faces detected`);
      }
    }

    function detectMotion(currentFrameData) {
      if (!previousFrameData) {
        previousFrameData = new Uint8ClampedArray(currentFrameData);
        return new Uint8Array(MASK_WIDTH * MASK_HEIGHT);
      }

      const motionMask = new Uint8Array(MASK_WIDTH * MASK_HEIGHT);

      for (let i = 0; i < currentFrameData.length; i += 4) {
        const idx = i / 4;
        const r = Math.abs(currentFrameData[i] - previousFrameData[i]);
        const g = Math.abs(currentFrameData[i + 1] - previousFrameData[i + 1]);
        const b = Math.abs(currentFrameData[i + 2] - previousFrameData[i + 2]);
        const diff = (r + g + b) / 3;

        motionMask[idx] = diff > MOTION_THRESHOLD ? 1 : 0;
      }

      previousFrameData = new Uint8ClampedArray(currentFrameData);
      return motionMask;
    }

    function updatePersistentMask(segmentationMask, motionMask) {
      for (let i = 0; i < persistentMask.length; i++) {
        persistentMask[i] *= (1 - MASK_DECAY_RATE);
      }

      if (primaryFaceBox) {
        const scaleX = MASK_WIDTH / videoRight.videoWidth;
        const scaleY = MASK_HEIGHT / videoRight.videoHeight;

        const expandedHeight = primaryFaceBox.height * FACE_REGION_SCALE;
        const expandedWidth = primaryFaceBox.width * 1.8;

        const regionX = Math.max(0, (primaryFaceBox.x - expandedWidth / 2) * scaleX);
        const regionY = Math.max(0, (primaryFaceBox.y - primaryFaceBox.height * 0.5) * scaleY);
        const regionW = Math.min(MASK_WIDTH - regionX, expandedWidth * scaleX);
        const regionH = Math.min(MASK_HEIGHT - regionY, expandedHeight * scaleY);

        for (let y = Math.floor(regionY); y < Math.floor(regionY + regionH); y++) {
          for (let x = Math.floor(regionX); x < Math.floor(regionX + regionW); x++) {
            const idx = y * MASK_WIDTH + x;
            if (idx >= 0 && idx < persistentMask.length) {
              if (segmentationMask[idx] > 128) {
                persistentMask[idx] = Math.min(1.0, persistentMask[idx] + MASK_STRENGTHEN_RATE);
              }
            }
          }
        }
      }

      for (let i = 0; i < persistentMask.length; i++) {
        if (motionMask[i] === 1 && persistentMask[i] < 0.3) {
          persistentMask[i] = 0;
        }
      }
    }

    function applyPersistentMask(frameData, segmentationMask) {
      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = MASK_WIDTH;
      tempCanvas.height = MASK_HEIGHT;
      const tempCtx = tempCanvas.getContext('2d');

      tempCtx.drawImage(videoRight, 0, 0, MASK_WIDTH, MASK_HEIGHT);
      const lowResFrame = tempCtx.getImageData(0, 0, MASK_WIDTH, MASK_HEIGHT);

      tempCtx.clearRect(0, 0, MASK_WIDTH, MASK_HEIGHT);
      const maskCanvas = document.createElement('canvas');
      maskCanvas.width = segmentationMask.width;
      maskCanvas.height = segmentationMask.height;
      const maskCtx = maskCanvas.getContext('2d');
      maskCtx.putImageData(segmentationMask, 0, 0);
      tempCtx.drawImage(maskCanvas, 0, 0, MASK_WIDTH, MASK_HEIGHT);
      const lowResMask = tempCtx.getImageData(0, 0, MASK_WIDTH, MASK_HEIGHT);

      const motionMask = detectMotion(lowResFrame.data);
      updatePersistentMask(lowResMask.data, motionMask);

      const scaleX = frameData.width / MASK_WIDTH;
      const scaleY = frameData.height / MASK_HEIGHT;

      for (let y = 0; y < frameData.height; y++) {
        for (let x = 0; x < frameData.width; x++) {
          const fullIdx = (y * frameData.width + x) * 4;
          const lowX = Math.floor(x / scaleX);
          const lowY = Math.floor(y / scaleY);
          const lowIdx = lowY * MASK_WIDTH + lowX;
          const maskValue = persistentMask[lowIdx];

          if (maskValue < 0.1) {
            frameData.data[fullIdx + 3] = 0;
          } else if (maskValue < 0.5) {
            frameData.data[fullIdx + 3] *= maskValue;
          }
        }
      }
    }

    function onSegmentationResults(results) {
      if (!virtualBgEnabled) return;

      try {
        frameCount++;

        const ctx = canvasRight.getContext('2d');

        if (!videoRight.videoWidth || !videoRight.videoHeight) {
          if (frameCount % 30 === 0) log('Waiting for video...');
          return;
        }

        canvasRight.width = videoRight.videoWidth;
        canvasRight.height = videoRight.videoHeight;

        // Draw blue background first
        ctx.save();
        ctx.fillStyle = '#1e3a8a';
        ctx.fillRect(0, 0, canvasRight.width, canvasRight.height);
        ctx.restore();

        if (!results.segmentationMask) {
          if (frameCount % 30 === 0) log('No segmentation mask - showing video');
          ctx.drawImage(videoRight, 0, 0, canvasRight.width, canvasRight.height);
          return;
        }

        if (frameCount === 1) {
          log('✓ Segmentation active - processing frames');
        }

        // Get segmentation mask data
        const maskCanvas = document.createElement('canvas');
        maskCanvas.width = canvasRight.width;
        maskCanvas.height = canvasRight.height;
        const maskCtx = maskCanvas.getContext('2d', { willReadFrequently: true });
        maskCtx.drawImage(results.segmentationMask, 0, 0, maskCanvas.width, maskCanvas.height);
        const maskData = maskCtx.getImageData(0, 0, maskCanvas.width, maskCanvas.height);

        // Get video frame
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = canvasRight.width;
        tempCanvas.height = canvasRight.height;
        const tempCtx = tempCanvas.getContext('2d', { willReadFrequently: true });
        tempCtx.drawImage(videoRight, 0, 0, tempCanvas.width, tempCanvas.height);
        const frameData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);

        // Apply masking
        if (ghostModeEnabled) {
          applyPersistentMask(frameData, maskData);
        } else {
          // Standard mode - keep person, remove background
          let personPixels = 0;
          let backgroundPixels = 0;

          for (let i = 0; i < frameData.data.length; i += 4) {
            const maskValue = maskData.data[i];
            if (maskValue < 128) {
              // Background pixel - make transparent
              frameData.data[i + 3] = 0;
              backgroundPixels++;
            } else {
              // Person pixel - keep opaque
              personPixels++;
            }
          }

          // Log stats every 60 frames (about once per second)
          if (frameCount % 60 === 0) {
            const totalPixels = personPixels + backgroundPixels;
            const personPercent = ((personPixels / totalPixels) * 100).toFixed(1);
            log(`Mask stats: ${personPercent}% person, ${(100 - personPercent).toFixed(1)}% background`);
          }
        }

        // Draw masked person over blue background
        tempCtx.putImageData(frameData, 0, 0);
        ctx.drawImage(tempCanvas, 0, 0);

      } catch (err) {
        log(`Segmentation error: ${err.message}`);
        console.error(err);
      }
    }

    bgToggle.addEventListener('click', () => {
      if (!stream) {
        log('⚠️ Start camera first');
        return;
      }

      virtualBgEnabled = !virtualBgEnabled;
      bgToggle.classList.toggle('active', virtualBgEnabled);

      if (virtualBgEnabled) {
        frameCount = 0;
        videoRight.classList.add('hidden');
        canvasRight.classList.remove('hidden');
        ghostToggle.classList.remove('disabled');
        log('✓ Virtual background enabled - waiting for frames...');
      } else {
        videoRight.classList.remove('hidden');
        canvasRight.classList.add('hidden');
        ghostToggle.classList.add('disabled');
        ghostToggle.classList.remove('active');
        ghostModeEnabled = false;
        log('✓ Virtual background disabled');
      }
    });

    ghostToggle.addEventListener('click', () => {
      if (!virtualBgEnabled) return;

      ghostModeEnabled = !ghostModeEnabled;
      ghostToggle.classList.toggle('active', ghostModeEnabled);

      if (ghostModeEnabled) {
        persistentMask.fill(0);
        previousFrameData = null;
        log('Ghost mode enabled - persistent mask active');
      } else {
        log('Ghost mode disabled');
      }
    });

    startBtn.addEventListener('click', startCamera);

    window.addEventListener('load', () => {
      log('Checking browser support...');
      if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
        log('✓ Camera API supported');
      } else {
        log('ERROR: Camera not supported');
        startBtn.disabled = true;
      }
    });

    window.addEventListener('beforeunload', () => {
      if (camera) camera.stop();
      if (stream) stream.getTracks().forEach(track => track.stop());
    });
  </script>
</body>
</html>
