<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Background Blocker - Professional Video Isolation</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
      min-height: 100vh;
      padding: 2rem;
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
    }

    .header {
      text-align: center;
      margin-bottom: 2rem;
    }

    .header h1 {
      font-size: 2.5rem;
      color: #1e293b;
      margin-bottom: 0.5rem;
      font-weight: 700;
    }

    .header p {
      color: #64748b;
      font-size: 1.1rem;
      margin-bottom: 1.5rem;
    }

    .btn-primary {
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.75rem 1.5rem;
      background: #2563eb;
      color: white;
      border: none;
      border-radius: 0.5rem;
      font-size: 1rem;
      font-weight: 500;
      cursor: pointer;
      transition: background 0.3s;
    }

    .btn-primary:hover:not(:disabled) {
      background: #1d4ed8;
    }

    .btn-primary:disabled {
      background: #cbd5e1;
      cursor: not-allowed;
    }

    .main-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 2rem;
      margin-top: 2rem;
    }

    .card {
      background: white;
      border-radius: 1rem;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      padding: 1.5rem;
    }

    .video-container {
      position: relative;
      aspect-ratio: 16/9;
      background: #0f172a;
      border-radius: 0.75rem;
      overflow: hidden;
      margin-bottom: 1rem;
    }

    video, canvas {
      width: 100%;
      height: 100%;
      object-fit: contain;
    }

    .video-placeholder {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #94a3b8;
    }

    .controls {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    .control-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0.75rem;
      background: #f8fafc;
      border-radius: 0.5rem;
    }

    .control-label {
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
    }

    .control-label span {
      font-size: 0.875rem;
      font-weight: 500;
      color: #334155;
    }

    .control-label small {
      font-size: 0.75rem;
      color: #64748b;
    }

    .toggle {
      position: relative;
      width: 3.5rem;
      height: 2rem;
      background: #cbd5e1;
      border-radius: 1rem;
      cursor: pointer;
      transition: background 0.3s;
    }

    .toggle.active {
      background: #2563eb;
    }

    .toggle.disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .toggle-slider {
      position: absolute;
      top: 0.25rem;
      left: 0.25rem;
      width: 1.5rem;
      height: 1.5rem;
      background: white;
      border-radius: 50%;
      transition: transform 0.3s;
    }

    .toggle.active .toggle-slider {
      transform: translateX(1.5rem);
    }

    .info-box {
      margin-top: 1rem;
      padding: 0.75rem;
      background: #dbeafe;
      border: 1px solid #93c5fd;
      border-radius: 0.5rem;
    }

    .info-box p {
      font-size: 0.875rem;
      color: #1e40af;
      line-height: 1.5;
    }

    .debug-panel h2 {
      font-size: 1.125rem;
      font-weight: 600;
      color: #1e293b;
      margin-bottom: 1rem;
    }

    .debug-log {
      height: 24rem;
      overflow-y: auto;
      background: #f8fafc;
      border: 1px solid #e2e8f0;
      border-radius: 0.5rem;
      padding: 1rem;
      font-family: 'Courier New', monospace;
      font-size: 0.75rem;
      color: #334155;
    }

    .toast-container {
      position: fixed;
      bottom: 2rem;
      right: 2rem;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      z-index: 1000;
    }

    .toast {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      padding: 0.75rem 1rem;
      background: white;
      border-radius: 0.5rem;
      box-shadow: 0 10px 15px rgba(0, 0, 0, 0.1);
      border-left: 4px solid;
      animation: slideIn 0.3s ease-out;
    }

    .toast.error { border-color: #dc2626; color: #991b1b; }
    .toast.warning { border-color: #f59e0b; color: #92400e; }
    .toast.info { border-color: #2563eb; color: #1e40af; }

    .toast-message {
      font-size: 0.875rem;
      font-weight: 500;
    }

    @keyframes slideIn {
      from {
        transform: translateX(100%);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }

    .hidden { display: none; }

    @media (max-width: 768px) {
      body { padding: 1rem; }
      .main-grid {
        grid-template-columns: 1fr;
        gap: 1rem;
      }
      .header h1 { font-size: 1.75rem; }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>wer bist du</h1>
      <p>v5.002</p>
      <button id="startBtn" class="btn-primary" disabled>
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"/>
          <circle cx="12" cy="13" r="4"/>
        </svg>
        <span id="btnText">Start Camera</span>
      </button>
    </div>

    <div class="main-grid">
      <div class="card">
        <div class="video-container">
          <video id="video" autoplay muted playsinline></video>
          <canvas id="canvas" class="hidden"></canvas>
          <div id="placeholder" class="video-placeholder">
            <svg width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"/>
              <circle cx="12" cy="13" r="4"/>
            </svg>
          </div>
        </div>

        <div class="controls">
          <div class="control-row">
            <span class="control-label">
              <span>Virtual Background</span>
            </span>
            <div id="bgToggle" class="toggle disabled">
              <div class="toggle-slider"></div>
            </div>
          </div>

          <div class="control-row">
            <div class="control-label">
              <span>Ghost Mode</span>
              <small>Hide background distractions</small>
            </div>
            <div id="ghostToggle" class="toggle disabled">
              <div class="toggle-slider"></div>
            </div>
          </div>
        </div>

        <div id="infoBox" class="info-box hidden">
          <p><strong>Ghost Mode Active:</strong> Only the person closest to the camera is visible. All background people, pets, and movement are hidden.</p>
        </div>
      </div>

      <div class="card debug-panel">
        <h2>Debug Log</h2>
        <div id="debugLog" class="debug-log"></div>
      </div>
    </div>
  </div>

  <div id="toastContainer" class="toast-container"></div>

  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/selfie_segmentation.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_detection"></script> <!-- option 1 --> 

  <script>
    const video = document.getElementById('video');
    const canvas = document.getElementById('canvas');
    const placeholder = document.getElementById('placeholder');
    const startBtn = document.getElementById('startBtn');
    const btnText = document.getElementById('btnText');
    const bgToggle = document.getElementById('bgToggle');
    const ghostToggle = document.getElementById('ghostToggle');
    const infoBox = document.getElementById('infoBox');
    const debugLog = document.getElementById('debugLog');
    const toastContainer = document.getElementById('toastContainer');

    let isStarted = false;
    let virtualBgEnabled = false;
    let ghostModeEnabled = false;
    let selfieSegmentation = null;
    let camera = null;
    let faceDetector = null; // option 1
    let latestFaces = [];    // option 1 

    function addDebug(msg) {
      const timestamp = new Date().toLocaleTimeString();
      debugLog.innerHTML += `[${timestamp}] ${msg}<br>`;
      debugLog.scrollTop = debugLog.scrollHeight;
      console.log(msg);
    }

    function showToast(message, type = 'info') {
      const toast = document.createElement('div');
      toast.className = `toast ${type}`;
      toast.innerHTML = `
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <circle cx="12" cy="12" r="10"/>
          <line x1="12" y1="8" x2="12" y2="12"/>
          <line x1="12" y1="16" x2="12.01" y2="16"/>
        </svg>
        <span class="toast-message">${message}</span>
      `;
      toastContainer.appendChild(toast);
      setTimeout(() => toast.remove(), 5000);
    }

    async function startCamera() {
      startBtn.disabled = true;
      btnText.textContent = 'Initializing...';
      addDebug('Requesting camera access...');

      try {
        const stream = await navigator.mediaDevices.getUserMedia({
          video: { width: 1280, height: 720, facingMode: 'user' },
          audio: false
        });

        video.srcObject = stream;
        await video.play();

        isStarted = true;
        placeholder.classList.add('hidden');
        btnText.textContent = 'Camera Active';
        bgToggle.classList.remove('disabled');
        addDebug('✓ Camera started successfully');
      } catch (err) {
        addDebug(`Camera error: ${err.message}`);
        showToast('Failed to access camera', 'error');
        startBtn.disabled = false;
        btnText.textContent = 'Start Camera';
      }
    }

    async function initializeMediaPipe() {
      addDebug('Initializing MediaPipe Selfie Segmentation...');

      try {
        selfieSegmentation = new SelfieSegmentation({
          locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/${file}`
        });

        selfieSegmentation.setOptions({
          modelSelection: 1,
          selfieMode: false,
        });

        selfieSegmentation.onResults(onSegmentationResults);

        camera = new Camera(video, {
          onFrame: async () => {
            if (virtualBgEnabled && selfieSegmentation) {
              await selfieSegmentation.send({ image: video });
            }
          },
          width: 1280,
          height: 720
        });

        await camera.start();
        addDebug('✓ MediaPipe initialized successfully');
      } catch (err) {
        addDebug(`MediaPipe initialization failed: ${err.message}`);
        showToast('Virtual background unavailable', 'warning');
      }
    }

    /// option 1 implementation functions /// 
    async function initFaceDetection() {
      faceDetector = new FaceDetection.FaceDetection({
        locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_detection/${file}`,
      });
      faceDetector.setOptions({
        model: 'short',
        minDetectionConfidence: 0.6,
      });
      faceDetector.onResults(onFaceResults);
    }

    function onFaceResults(results) {
      latestFaces = results.detections || [];
    
      // If multiple faces found, alert user
      if (latestFaces.length > 1) {
        showToast(`⚠️ Multiple people detected (${latestFaces.length})`, 'warning');
      }
    
      // Pick primary face (largest or most central)
      if (latestFaces.length > 0) {
        const primary = pickPrimaryFace(latestFaces);
        drawFaceBox(primary);
      }
    }
    
    function pickPrimaryFace(faces) {
      const videoW = video.videoWidth;
      const videoH = video.videoHeight;
      return faces.reduce((best, f) => {
        const box = f.boundingBox;
        const cx = (box.xCenter * videoW);
        const cy = (box.yCenter * videoH);
        const dist = Math.abs(cx - videoW/2) + Math.abs(cy - videoH/2);
        if (!best) return { face: f, dist };
        return dist < best.dist ? { face: f, dist } : best;
      }, null).face;
    }
    
    function drawFaceBox(face) {
      if (!face || !face.boundingBox) return;
      const { xCenter, yCenter, width, height } = face.boundingBox;
      const ctx = outputCanvas.getContext('2d');
      ctx.strokeStyle = '#00bfff';
      ctx.lineWidth = 2;
      ctx.strokeRect(
        (xCenter - width / 2) * outputCanvas.width,
        (yCenter - height / 2) * outputCanvas.height,
        width * outputCanvas.width,
        height * outputCanvas.height
      );
    }
    
    // Call this once after camera starts:
    initFaceDetection();
    
    // Update on each video frame:
    async function processFrame() {
      await selfieSegmentation.send({ image: video });
      await faceDetector.send({ image: video });
      requestAnimationFrame(processFrame);
    }

    /// end option 1 implementation 

    function onSegmentationResults(results) {
      if (!virtualBgEnabled) return;
    
      const ctx = canvas.getContext('2d');
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
    
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = '#1e3a8a';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    
      if (!results.segmentationMask) {
        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
        return;
      }
      
      const maskCanvas = document.createElement('canvas');
      maskCanvas.width = canvas.width;
      maskCanvas.height = canvas.height;
      const maskCtx = maskCanvas.getContext('2d');
  
      maskCtx.filter = 'blur(10px)'; // Adjust radius for more/less smoothing
      maskCtx.drawImage(results.segmentationMask, 0, 0, maskCanvas.width, maskCanvas.height);
    
      const maskData = maskCtx.getImageData(0, 0, maskCanvas.width, maskCanvas.height);
    
      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = canvas.width;
      tempCanvas.height = canvas.height;
      const tempCtx = tempCanvas.getContext('2d');
    
      tempCtx.drawImage(video, 0, 0, tempCanvas.width, tempCanvas.height);
      const frameData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);

      if (ghostModeEnabled) {
        identifyPrimaryPerson(maskData, frameData); // existing ghost mode logic
      } else {
        for (let i = 0; i < frameData.data.length; i += 4) {
          const alpha = maskData.data[i] / 255; // convert blurred mask to 0-1
          frameData.data[i + 3] = frameData.data[i + 3] * alpha;
        }
      }
    
      tempCtx.putImageData(frameData, 0, 0);
      ctx.drawImage(tempCanvas, 0, 0);
    }

    function identifyPrimaryPerson(maskData, frameData) {
      const width = maskData.width;
      const height = maskData.height;
      const centerX = width / 2;
      const centerY = height / 2;

      const personMask = new Uint8Array(width * height);
      for (let i = 0; i < maskData.data.length; i += 4) {
        personMask[i / 4] = maskData.data[i] > 128 ? 1 : 0;
      }

      const visited = new Uint8Array(width * height);
      const components = [];

      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          const idx = y * width + x;
          if (personMask[idx] === 1 && visited[idx] === 0) {
            const component = floodFill(personMask, visited, x, y, width, height);
            if (component.length > 500) {
              const sumX = component.reduce((sum, idx) => sum + (idx % width), 0);
              const sumY = component.reduce((sum, idx) => sum + Math.floor(idx / width), 0);
              components.push({
                pixels: component,
                centerX: sumX / component.length,
                centerY: sumY / component.length,
                size: component.length
              });
            }
          }
        }
      }

      if (components.length === 0) {
        for (let i = 0; i < frameData.data.length; i += 4) {
          frameData.data[i + 3] = 0;
        }
        return;
      }

      let primaryComponent = components[0];
      let bestScore = 0;

      for (const comp of components) {
        const distFromCenter = Math.sqrt(
          Math.pow(comp.centerX - centerX, 2) +
          Math.pow(comp.centerY - centerY, 2)
        );
        const score = comp.size / (1 + distFromCenter * 0.01);
        if (score > bestScore) {
          bestScore = score;
          primaryComponent = comp;
        }
      }

      const primaryMask = new Uint8Array(width * height);
      for (const idx of primaryComponent.pixels) {
        primaryMask[idx] = 1;
      }

      for (let i = 0; i < frameData.data.length; i += 4) {
        if (primaryMask[i / 4] === 0) {
          frameData.data[i + 3] = 0;
        }
      }

      if (components.length > 1 && Math.random() < 0.1) {
        addDebug(`Ghost Mode: ${components.length} people detected, showing primary only`);
        showToast(`${components.length} people detected - hiding distractions`, 'warning');
      }
    }

    function floodFill(mask, visited, startX, startY, width, height) {
      const component = [];
      const stack = [[startX, startY]];

      while (stack.length > 0) {
        const [x, y] = stack.pop();
        const idx = y * width + x;

        if (x < 0 || x >= width || y < 0 || y >= height) continue;
        if (visited[idx] === 1 || mask[idx] === 0) continue;

        visited[idx] = 1;
        component.push(idx);

        stack.push([x + 1, y], [x - 1, y], [x, y + 1], [x, y - 1]);
      }

      return component;
    }

    function applyStandardMask(maskData, frameData) {
      for (let i = 0; i < frameData.data.length; i += 4) {
        if (maskData.data[i] < 128) {
          frameData.data[i + 3] = 0;
        }
      }
    }

    async function toggleVirtualBackground() {
      if (!isStarted) return;

      if (!virtualBgEnabled && !selfieSegmentation) {
        await initializeMediaPipe();
      }

      virtualBgEnabled = !virtualBgEnabled;
      bgToggle.classList.toggle('active', virtualBgEnabled);

      if (virtualBgEnabled) {
        video.classList.add('hidden');
        canvas.classList.remove('hidden');
        ghostToggle.classList.remove('disabled');
        addDebug('Virtual background enabled');
      } else {
        video.classList.remove('hidden');
        canvas.classList.add('hidden');
        ghostToggle.classList.add('disabled');
        ghostToggle.classList.remove('active');
        ghostModeEnabled = false;
        infoBox.classList.add('hidden');
        addDebug('Virtual background disabled');
      }
    }

    function toggleGhostMode() {
      if (!isStarted || !virtualBgEnabled) return;

      ghostModeEnabled = !ghostModeEnabled;
      ghostToggle.classList.toggle('active', ghostModeEnabled);
      infoBox.classList.toggle('hidden', !ghostModeEnabled);

      addDebug(ghostModeEnabled
        ? 'Ghost mode enabled - only primary person visible'
        : 'Ghost mode disabled');
    }

    startBtn.addEventListener('click', startCamera);
    bgToggle.addEventListener('click', toggleVirtualBackground);
    ghostToggle.addEventListener('click', toggleGhostMode);

    window.addEventListener('load', () => {
      addDebug('Checking browser support...');
      if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
        addDebug('✓ Camera API supported');
        startBtn.disabled = false;
      } else {
        addDebug('ERROR: Camera API not supported');
        showToast('Browser does not support camera access', 'error');
      }
    });

    window.addEventListener('beforeunload', () => {
      if (camera) camera.stop();
      if (video.srcObject) {
        video.srcObject.getTracks().forEach(track => track.stop());
      }
    });
  </script>
</body>
</html>
