<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>wer bist du</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: system-ui, sans-serif;
      background: #f1f5f9;
      padding: 2rem;
    }
    .container {
      max-width: 1400px;
      margin: 0 auto;
    }
    .header {
      text-align: center;
      margin-bottom: 2rem;
    }
    .header h1 {
      font-size: 2rem;
      font-weight: 700;
      color: #1e293b;
    }
    .header h3 {
      margin: 0 0 15px 0;
      color: #64748b;
    }

    .video-row {
      display: flex;
      gap: 1.5rem;
      margin-bottom: 1.5rem;
    }

    .card {
      flex: 1;
      background: white;
      border-radius: 1rem;
      box-shadow: 0 4px 10px rgba(0,0,0,0.08);
      padding: 1rem;
    }

    .card h3 {
      margin-bottom: 0.5rem;
      color: #1e3a8a;
      font-size: 1.1rem;
    }

    .video-container {
      position: relative;
      background: #0f172a;
      border-radius: 0.75rem;
      overflow: hidden;
      aspect-ratio: 16/9;
    }

    video, canvas {
      width: 100%;
      height: 100%;
      object-fit: contain;
    }

    .hidden {
      display: none !important;
    }

    .controls {
      margin-top: 1rem;
      display: flex;
      gap: 1rem;
      align-items: center;
    }

    .control-group {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .control-label {
      font-size: 0.875rem;
      color: #334155;
    }

    .toggle {
      position: relative;
      width: 3rem;
      height: 1.5rem;
      background: #cbd5e1;
      border-radius: 1rem;
      cursor: pointer;
      transition: background 0.3s;
    }

    .toggle.disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .toggle.active {
      background: #2563eb;
    }

    .toggle-slider {
      position: absolute;
      top: 0.2rem;
      left: 0.2rem;
      width: 1.1rem;
      height: 1.1rem;
      background: white;
      border-radius: 50%;
      transition: transform 0.3s;
    }

    .toggle.active .toggle-slider {
      transform: translateX(1.4rem);
    }

    .debug-panel {
      background: white;
      border-radius: 1rem;
      box-shadow: 0 4px 10px rgba(0,0,0,0.08);
      padding: 1rem;
    }

    .debug-panel h2 {
      color: #1e293b;
      font-size: 1.2rem;
      margin-bottom: 0.5rem;
    }

    .debug-log {
      height: 18rem;
      overflow-y: auto;
      background: #f8fafc;
      border: 1px solid #e2e8f0;
      border-radius: 0.5rem;
      padding: 0.5rem;
      font-family: monospace;
      font-size: 0.8rem;
      color: #334155;
    }

    button {
      padding: 12px 24px;
      font-size: 16px;
      border: none;
      border-radius: 8px;
      background-color: #007bff;
      color: white;
      cursor: pointer;
      transition: background-color 0.3s;
    }

    button:hover:not(:disabled) {
      background-color: #0056b3;
    }

    button:disabled {
      background-color: #ccc;
      cursor: not-allowed;
    }

    .toast {
      visibility: hidden;
      display: flex;
      width: 348px;
      min-height: 44px;
      flex-direction: row;
      align-items: center;
      gap: 8px;
      border-radius: 8px;
      background: #F9F9F9;
      box-shadow: 0 0 8px 0 rgba(22, 51, 95, 0.10);
      color: #333;
      text-align: left;
      padding: 12px 16px;
      position: fixed;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 1000;
      transition: visibility 0.5s, opacity 0.5s;
      opacity: 0;
    }

    .toast.show {
      visibility: visible;
      opacity: 1;
    }

    #faceToast {
      border: 1px solid #F0775C;
    }

    @media (max-width: 768px) {
      .video-row {
        flex-direction: column;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>wer bist du</h1>
      <h3>v4.011</h3>
      <button id="startBtn">Start Camera</button>
    </div>

    <div class="video-row">
      <div class="card">
        <!-- <h3>Face Detection View</h3> -->
        <div class="video-container">
          <video id="videoLeft" autoplay muted playsinline></video>
          <canvas id="canvasLeft" class="hidden"></canvas>
        </div>
      </div>

      <div class="card">
        <!-- <h3>Background Isolation View</h3> -->
        <div class="video-container">
          <video id="videoRight" autoplay muted playsinline></video>
          <canvas id="canvasRight" class="hidden"></canvas>
        </div>
        <div class="controls">
          <div class="control-group">
            <span class="control-label">Virtual BG</span>
            <div id="bgToggle" class="toggle disabled">
              <div class="toggle-slider"></div>
            </div>
          </div>
          <div class="control-group">
            <span class="control-label">Ghost Mode</span>
            <div id="ghostToggle" class="toggle disabled">
              <div class="toggle-slider"></div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="debug-panel">
      <div id="debugLog" class="debug-log"></div>
    </div>
  </div>

  <div id="faceToast" class="toast">
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none">
      <path d="M12 8V12M12 16H12.01M22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12Z" stroke="#D42802" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
    </svg>
    Multiple faces detected in the background!
  </div>

  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/selfie_segmentation.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_detection/face_detection.js"></script>

  <script>
    const videoLeft = document.getElementById('videoLeft');
    const videoRight = document.getElementById('videoRight');
    const canvasLeft = document.getElementById('canvasLeft');
    const canvasRight = document.getElementById('canvasRight');
    const startBtn = document.getElementById('startBtn');
    const bgToggle = document.getElementById('bgToggle');
    const ghostToggle = document.getElementById('ghostToggle');
    const debugLog = document.getElementById('debugLog');
    const faceToast = document.getElementById('faceToast');

    let stream = null;
    let virtualBgEnabled = false;
    let ghostModeEnabled = false;
    let selfieSegmentation = null;
    let faceDetection = null;
    let camera = null;
    let latestFaces = [];
    let frameCount = 0;
    let lastFaceCount = 0; 

    const MASK_WIDTH = 320;
    const MASK_HEIGHT = 180;
    let persistentMask = null;
    let previousFrameData = null;
    let primaryFaceBox = null;

    const MASK_STRENGTHEN_RATE = 0.3;
    const MASK_DECAY_RATE = 0.02;
    const MOTION_THRESHOLD = 15;
    const FACE_REGION_SCALE = 3.5;

    function log(msg) {
      const timestamp = new Date().toLocaleTimeString();
      debugLog.innerHTML += `[${timestamp}] ${msg}<br>`;
      debugLog.scrollTop = debugLog.scrollHeight;
      console.log(msg);
    }

    function showToast(toast) {
      toast.className = "toast show";
      setTimeout(() => { toast.className = "toast"; }, 5000);
    }

    async function startCamera() {
      try {
        startBtn.disabled = true;
        startBtn.textContent = 'Initializing...';
        log('Requesting camera...');

        stream = await navigator.mediaDevices.getUserMedia({
          video: { width: 1280, height: 720, facingMode: 'user' },
          audio: false
        });

        videoLeft.srcObject = stream;
        videoRight.srcObject = stream;

        await videoLeft.play();
        await videoRight.play();

        log('✓ Camera started on both feeds');
        startBtn.textContent = 'Camera Active';
        bgToggle.classList.remove('disabled');

        await initMediaPipe();

      } catch (err) {
        log('Camera error: ' + err.message);
        startBtn.disabled = false;
        startBtn.textContent = 'Start Camera';
      }
    }

    async function initMediaPipe() {
      log('Initializing MediaPipe...');

      try {
        selfieSegmentation = new SelfieSegmentation({
          locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/${f}`
        });
        selfieSegmentation.setOptions({
          modelSelection: 1,
          selfieMode: false
        });
        selfieSegmentation.onResults(onSegmentationResults);

        faceDetection = new FaceDetection({
          locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_detection/${f}`
        });
        faceDetection.setOptions({
          model: 'short',
          minDetectionConfidence: 0.5
        });
        faceDetection.onResults(onFaceResults);

        persistentMask = new Float32Array(MASK_WIDTH * MASK_HEIGHT);

        camera = new Camera(videoRight, {
          onFrame: async () => {
            await faceDetection.send({ image: videoLeft });
            if (virtualBgEnabled) {
              await selfieSegmentation.send({ image: videoRight });
            }
          },
          width: 1280,
          height: 720
        });

        await camera.start();
        log('✓ MediaPipe initialized');
        log('✓ Face detection running continuously');
        log('✓ Persistent mask system ready');

      } catch (err) {
        log(`MediaPipe error: ${err.message}`);
      }
    }

    function onFaceResults(results) {
      latestFaces = results.detections || [];
    
      const ctx = canvasLeft.getContext('2d');
      canvasLeft.width = videoLeft.videoWidth;
      canvasLeft.height = videoLeft.videoHeight;
    
      ctx.clearRect(0, 0, canvasLeft.width, canvasLeft.height);
      ctx.drawImage(videoLeft, 0, 0);
    
      const videoW = videoLeft.videoWidth;
      const videoH = videoLeft.videoHeight;
      const centerX = videoW / 2;
      const centerY = videoH / 2;
    
      let bestFace = null;
      let bestScore = -1;
    
      for (const detection of latestFaces) {
        const box = detection.boundingBox;
        const fx = box.xCenter * videoW;
        const fy = box.yCenter * videoH;
        const fw = box.width * videoW;
        const fh = box.height * videoH;
    
        const distFromCenter = Math.sqrt(
          Math.pow(fx - centerX, 2) + Math.pow(fy - centerY, 2)
        );
    
        const area = fw * fh;
        const score = area / (1 + distFromCenter * 0.001);
    
        if (score > bestScore) {
          bestScore = score;
          bestFace = { x: fx, y: fy, width: fw, height: fh };
        }
    
        ctx.strokeStyle = '#00ff00';
        ctx.lineWidth = 2;
        ctx.strokeRect(
          fx - fw / 2,
          fy - fh / 2,
          fw,
          fh
        );
      }
    
      if (bestFace) {
        primaryFaceBox = bestFace;
        ctx.strokeStyle = '#00bfff';
        ctx.lineWidth = 3;
        ctx.strokeRect(
          bestFace.x - bestFace.width / 2,
          bestFace.y - bestFace.height / 2,
          bestFace.width,
          bestFace.height
        );
      } else {
        primaryFaceBox = null;
      }
    
      canvasLeft.classList.remove('hidden');
      videoLeft.classList.add('hidden');
    
      const faceCount = latestFaces.length;
      if (faceCount !== lastFaceCount) {
        lastFaceCount = faceCount;
        log(`Faces detected: ${faceCount}`);
        if (faceCount > 1) {
          showToast(faceToast);
          log(`⚠️ ${faceCount} faces detected`);
        }
      }
    }

    function detectMotion(currentFrameData) {
      if (!previousFrameData) {
        previousFrameData = new Uint8ClampedArray(currentFrameData);
        return new Uint8Array(MASK_WIDTH * MASK_HEIGHT);
      }

      const motionMask = new Uint8Array(MASK_WIDTH * MASK_HEIGHT);

      for (let i = 0; i < currentFrameData.length; i += 4) {
        const idx = i / 4;
        const r = Math.abs(currentFrameData[i] - previousFrameData[i]);
        const g = Math.abs(currentFrameData[i + 1] - previousFrameData[i + 1]);
        const b = Math.abs(currentFrameData[i + 2] - previousFrameData[i + 2]);
        const diff = (r + g + b) / 3;

        motionMask[idx] = diff > MOTION_THRESHOLD ? 1 : 0;
      }

      previousFrameData = new Uint8ClampedArray(currentFrameData);
      return motionMask;
    }

    // changes here ---
    function identifyPrimaryPerson(maskData, frameData) {
      const width = maskData.width;
      const height = maskData.height;
      const centerX = width / 2;
      const centerY = height / 2;
    
      // Build binary person mask from (blurred) segmentation
      const personMask = new Uint8Array(width * height);
      for (let i = 0; i < maskData.data.length; i += 4) {
        personMask[i / 4] = maskData.data[i] > 128 ? 1 : 0;
      }
    
      // Connected components
      const visited = new Uint8Array(width * height);
      const components = [];
    
      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          const idx = y * width + x;
          if (personMask[idx] === 1 && visited[idx] === 0) {
            const component = floodFill(personMask, visited, x, y, width, height);
            if (component.length > 500) {
              // compute bbox and center for this component
              let minX = width, minY = height, maxX = 0, maxY = 0;
              let sumX = 0, sumY = 0;
              for (const pIdx of component) {
                const px = pIdx % width;
                const py = Math.floor(pIdx / width);
                if (px < minX) minX = px;
                if (py < minY) minY = py;
                if (px > maxX) maxX = px;
                if (py > maxY) maxY = py;
                sumX += px;
                sumY += py;
              }
              components.push({
                pixels: component,
                centerX: sumX / component.length,
                centerY: sumY / component.length,
                size: component.length,
                minX, minY, maxX, maxY
              });
            }
          }
        }
      }
    
      // If no components -> hide everything
      if (components.length === 0) {
        for (let i = 0; i < frameData.data.length; i += 4) {
          frameData.data[i + 3] = 0;
        }
        return;
      }
    
      // Select primary component:
      let primaryComponent = components[0];
    
      if (primaryFaceBox && videoRight.videoWidth && videoRight.videoHeight) {
        // Convert primaryFaceBox (video coords) to mask coords
        const scaleX = width / videoRight.videoWidth;
        const scaleY = height / videoRight.videoHeight;
    
        const faceMinX = Math.max(0, Math.floor((primaryFaceBox.x - primaryFaceBox.width / 2) * scaleX));
        const faceMinY = Math.max(0, Math.floor((primaryFaceBox.y - primaryFaceBox.height / 2) * scaleY));
        const faceMaxX = Math.min(width - 1, Math.ceil((primaryFaceBox.x + primaryFaceBox.width / 2) * scaleX));
        const faceMaxY = Math.min(height - 1, Math.ceil((primaryFaceBox.y + primaryFaceBox.height / 2) * scaleY));
        const faceCenterX = (faceMinX + faceMaxX) / 2;
        const faceCenterY = (faceMinY + faceMaxY) / 2;
    
        // find component with maximum bounding-box overlap with face box
        let bestOverlap = 0;
        let bestIdx = -1;
        for (let i = 0; i < components.length; i++) {
          const comp = components[i];
          const overlapW = Math.max(0, Math.min(comp.maxX, faceMaxX) - Math.max(comp.minX, faceMinX) + 1);
          const overlapH = Math.max(0, Math.min(comp.maxY, faceMaxY) - Math.max(comp.minY, faceMinY) + 1);
          const overlapArea = overlapW * overlapH;
          if (overlapArea > bestOverlap) {
            bestOverlap = overlapArea;
            bestIdx = i;
          }
        }
    
        if (bestIdx >= 0) {
          primaryComponent = components[bestIdx];
        } else {
          // fallback — choose component whose center is closest to the face center
          let bestDist = Infinity;
          for (const comp of components) {
            const dist = Math.hypot(comp.centerX - faceCenterX, comp.centerY - faceCenterY);
            if (dist < bestDist) {
              bestDist = dist;
              primaryComponent = comp;
            }
          }
        }
      } else {
        // fallback: choose by size + center proximity (existing heuristic)
        let bestScore = -Infinity;
        for (const comp of components) {
          const distFromCenter = Math.hypot(comp.centerX - centerX, comp.centerY - centerY);
          const score = comp.size / (1 + distFromCenter * 0.01);
          if (score > bestScore) {
            bestScore = score;
            primaryComponent = comp;
          }
        }
      }
    
      // Build a primary mask from the chosen component (and dilate slightly)
      const primaryMask = new Uint8Array(width * height);
      for (const idx of primaryComponent.pixels) {
        primaryMask[idx] = 1;
      }
    
      // Small dilation to make mask robust when objects touch edges
      const dilationRadius = 2;
      if (dilationRadius > 0) {
        const dilated = new Uint8Array(width * height);
        for (let p = 0; p < width * height; p++) {
          if (primaryMask[p]) {
            const px = p % width;
            const py = Math.floor(p / width);
            for (let dy = -dilationRadius; dy <= dilationRadius; dy++) {
              for (let dx = -dilationRadius; dx <= dilationRadius; dx++) {
                const nx = px + dx;
                const ny = py + dy;
                if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                  dilated[ny * width + nx] = 1;
                }
              }
            }
          }
        }
        primaryMask.set(dilated);
      }
    
      // Apply primaryMask to frameData (hide pixels not in primary mask)
      for (let i = 0; i < frameData.data.length; i += 4) {
        if (primaryMask[i / 4] === 0) {
          frameData.data[i + 3] = 0;
        }
      }
    
      // Use faceDetection results for "multiple people" logging (more reliable)
      if (latestFaces && latestFaces.length > 1) {
        log(`Ghost Mode: ${latestFaces.length} faces detected, showing primary only`);
        showToast(`${latestFaces.length} people detected - hiding distractions`, 'warning');
      }
    }
    
    function floodFill(mask, visited, startX, startY, width, height) {
      const component = [];
      const stack = [[startX, startY]];
    
      while (stack.length > 0) {
        const [x, y] = stack.pop();
        const idx = y * width + x;
    
        if (x < 0 || x >= width || y < 0 || y >= height) continue;
        if (visited[idx] === 1 || mask[idx] === 0) continue;
    
        visited[idx] = 1;
        component.push(idx);
    
        stack.push([x + 1, y], [x - 1, y], [x, y + 1], [x, y - 1]);
      }
    
      return component;
    }

    function onSegmentationResults(results) {
      if (!virtualBgEnabled) return;
    
      try {
        frameCount++;
    
        const ctx = canvasRight.getContext('2d');
    
        if (!videoRight.videoWidth || !videoRight.videoHeight) {
          if (frameCount % 30 === 0) log('Waiting for video...');
          return;
        }
    
        canvasRight.width = videoRight.videoWidth;
        canvasRight.height = videoRight.videoHeight;
    
        // Draw blue background first
        ctx.save();
        ctx.fillStyle = '#1e3a8a';
        ctx.fillRect(0, 0, canvasRight.width, canvasRight.height);
        ctx.restore();
    
        if (!results.segmentationMask) {
          if (frameCount % 30 === 0) log('No segmentation mask - showing video');
          ctx.drawImage(videoRight, 0, 0, canvasRight.width, canvasRight.height);
          return;
        }
    
        if (frameCount === 1) {
          log('✓ Segmentation active - processing frames');
        }
    
        // Get segmentation mask data with blur for smoother edges
        const maskCanvas = document.createElement('canvas');
        maskCanvas.width = canvasRight.width;
        maskCanvas.height = canvasRight.height;
        const maskCtx = maskCanvas.getContext('2d', { willReadFrequently: true });
        
        // Apply blur filter for smoother mask edges
        maskCtx.filter = 'blur(2px)';
        maskCtx.drawImage(results.segmentationMask, 0, 0, maskCanvas.width, maskCanvas.height);
        const maskData = maskCtx.getImageData(0, 0, maskCanvas.width, maskCanvas.height);
    
        // Get video frame
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = canvasRight.width;
        tempCanvas.height = canvasRight.height;
        const tempCtx = tempCanvas.getContext('2d', { willReadFrequently: true });
        tempCtx.drawImage(videoRight, 0, 0, tempCanvas.width, tempCanvas.height);
        const frameData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
    
        // Apply masking
        if (ghostModeEnabled) {
          identifyPrimaryPerson(maskData, frameData);
        } else {
          // Standard mode - use alpha blending for smoother edges
          for (let i = 0; i < frameData.data.length; i += 4) {
            const alpha = maskData.data[i] / 255; // Convert blurred mask to 0-1
            frameData.data[i + 3] = frameData.data[i + 3] * alpha;
          }
        }
    
        // Draw masked person over blue background
        tempCtx.putImageData(frameData, 0, 0);
        ctx.drawImage(tempCanvas, 0, 0);
    
      } catch (err) {
        log(`Segmentation error: ${err.message}`);
        console.error(err);
      }
    }

    bgToggle.addEventListener('click', () => {
      if (!stream) {
        log('⚠️ Start camera first');
        return;
      }

      virtualBgEnabled = !virtualBgEnabled;
      bgToggle.classList.toggle('active', virtualBgEnabled);

      if (virtualBgEnabled) {
        frameCount = 0;
        videoRight.classList.add('hidden');
        canvasRight.classList.remove('hidden');
        ghostToggle.classList.remove('disabled');
        log('✓ Virtual background enabled - waiting for frames...');
      } else {
        videoRight.classList.remove('hidden');
        canvasRight.classList.add('hidden');
        ghostToggle.classList.add('disabled');
        ghostToggle.classList.remove('active');
        ghostModeEnabled = false;
        log('✓ Virtual background disabled');
      }
    });

    ghostToggle.addEventListener('click', () => {
      if (!virtualBgEnabled) return;

      ghostModeEnabled = !ghostModeEnabled;
      ghostToggle.classList.toggle('active', ghostModeEnabled);

      if (ghostModeEnabled) {
        persistentMask.fill(0);
        previousFrameData = null;
        log('Ghost mode enabled - persistent mask active');
      } else {
        log('Ghost mode disabled');
      }
    });

    startBtn.addEventListener('click', startCamera);

    window.addEventListener('load', () => {
      log('Checking browser support...');
      if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
        log('✓ Camera API supported');
      } else {
        log('ERROR: Camera not supported');
        startBtn.disabled = true;
      }
    });

    window.addEventListener('beforeunload', () => {
      if (camera) camera.stop();
      if (stream) stream.getTracks().forEach(track => track.stop());
    });
  </script>
</body>
</html>
