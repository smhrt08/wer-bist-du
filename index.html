<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>wer bist du</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
      min-height: 100vh;
      padding: 2rem;
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
    }

    .header {
      text-align: center;
      margin-bottom: 2rem;
    }

    .header h1 {
      font-size: 2.5rem;
      color: #1e293b;
      margin-bottom: 0.5rem;
      font-weight: 700;
    }

    .header p {
      color: #64748b;
      font-size: 1.1rem;
      margin-bottom: 1.5rem;
    }

    .btn-primary {
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.75rem 1.5rem;
      background: #2563eb;
      color: white;
      border: none;
      border-radius: 0.5rem;
      font-size: 1rem;
      font-weight: 500;
      cursor: pointer;
      transition: background 0.3s;
    }

    .btn-primary:hover:not(:disabled) {
      background: #1d4ed8;
    }

    .btn-primary:disabled {
      background: #cbd5e1;
      cursor: not-allowed;
    }

    .main-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 2rem;
      margin-top: 2rem;
    }

    .card {
      background: white;
      border-radius: 1rem;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      padding: 1.5rem;
    }

    .video-container {
      position: relative;
      aspect-ratio: 16/9;
      background: #0f172a;
      border-radius: 0.75rem;
      overflow: hidden;
      margin-bottom: 1rem;
    }

    video, canvas {
      width: 100%;
      height: 100%;
      object-fit: contain;
    }

    .video-placeholder {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #94a3b8;
    }

    .controls {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    .control-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0.75rem;
      background: #f8fafc;
      border-radius: 0.5rem;
    }

    .control-label {
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
    }

    .control-label span {
      font-size: 0.875rem;
      font-weight: 500;
      color: #334155;
    }

    .control-label small {
      font-size: 0.75rem;
      color: #64748b;
    }

    .toggle {
      position: relative;
      width: 3.5rem;
      height: 2rem;
      background: #cbd5e1;
      border-radius: 1rem;
      cursor: pointer;
      transition: background 0.3s;
    }

    .toggle.active {
      background: #2563eb;
    }

    .toggle.disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .toggle-slider {
      position: absolute;
      top: 0.25rem;
      left: 0.25rem;
      width: 1.5rem;
      height: 1.5rem;
      background: white;
      border-radius: 50%;
      transition: transform 0.3s;
    }

    .toggle.active .toggle-slider {
      transform: translateX(1.5rem);
    }

    .info-box {
      margin-top: 1rem;
      padding: 0.75rem;
      background: #dbeafe;
      border: 1px solid #93c5fd;
      border-radius: 0.5rem;
    }

    .info-box p {
      font-size: 0.875rem;
      color: #1e40af;
      line-height: 1.5;
    }

    .debug-panel h2 {
      font-size: 1.125rem;
      font-weight: 600;
      color: #1e293b;
      margin-bottom: 1rem;
    }

    .debug-log {
      height: 24rem;
      overflow-y: auto;
      background: #f8fafc;
      border: 1px solid #e2e8f0;
      border-radius: 0.5rem;
      padding: 1rem;
      font-family: 'Courier New', monospace;
      font-size: 0.75rem;
      color: #334155;
    }

    .toast-container {
      position: fixed;
      bottom: 2rem;
      right: 2rem;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      z-index: 1000;
    }

    .toast {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      padding: 0.75rem 1rem;
      background: white;
      border-radius: 0.5rem;
      box-shadow: 0 10px 15px rgba(0, 0, 0, 0.1);
      border-left: 4px solid;
      animation: slideIn 0.3s ease-out;
    }

    .toast.error { border-color: #dc2626; color: #991b1b; }
    .toast.warning { border-color: #f59e0b; color: #92400e; }
    .toast.info { border-color: #2563eb; color: #1e40af; }

    .toast-message {
      font-size: 0.875rem;
      font-weight: 500;
    }

    @keyframes slideIn {
      from {
        transform: translateX(100%);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }

    .hidden { display: none; }

    @media (max-width: 768px) {
      body { padding: 1rem; }
      .main-grid {
        grid-template-columns: 1fr;
        gap: 1rem;
      }
      .header h1 { font-size: 1.75rem; }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>wer bist du</h1>
      <p>v6.002</p>
      <button id="startBtn" class="btn-primary" disabled>
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"/>
          <circle cx="12" cy="13" r="4"/>
        </svg>
        <span id="btnText">Start Camera</span>
      </button>
    </div>

    <div class="main-grid">
      <div class="card">
        <div class="video-container">
          <video id="video" autoplay muted playsinline></video>
          <canvas id="canvas" class="hidden"></canvas>
          <div id="placeholder" class="video-placeholder">
            <svg width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"/>
              <circle cx="12" cy="13" r="4"/>
            </svg>
          </div>
        </div>

        <div class="controls">
          <div class="control-row">
            <span class="control-label">
              <span>Virtual Background</span>
            </span>
            <div id="bgToggle" class="toggle disabled">
              <div class="toggle-slider"></div>
            </div>
          </div>

          <div class="control-row">
            <div class="control-label">
              <span>Ghost Mode</span>
              <small>Aggressive background suppression</small>
            </div>
            <div id="ghostToggle" class="toggle disabled">
              <div class="toggle-slider"></div>
            </div>
          </div>
        </div>

        <div id="infoBox" class="info-box hidden">
          <p><strong>Ghost Mode Active:</strong> Persistent mask tracks primary person. All background movement (pets, people, objects) is aggressively hidden even when connected.</p>
        </div>
      </div>

      <div class="card debug-panel">
        <h2>Debug Log</h2>
        <div id="debugLog" class="debug-log"></div>
      </div>
    </div>
  </div>

  <div id="toastContainer" class="toast-container"></div>

  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/selfie_segmentation.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_detection/face_detection.js"></script>

  <script>
    const video = document.getElementById('video');
    const canvas = document.getElementById('canvas');
    const placeholder = document.getElementById('placeholder');
    const startBtn = document.getElementById('startBtn');
    const btnText = document.getElementById('btnText');
    const bgToggle = document.getElementById('bgToggle');
    const ghostToggle = document.getElementById('ghostToggle');
    const infoBox = document.getElementById('infoBox');
    const debugLog = document.getElementById('debugLog');
    const toastContainer = document.getElementById('toastContainer');

    let isStarted = false;
    let virtualBgEnabled = false;
    let ghostModeEnabled = false;
    let selfieSegmentation = null;
    let faceDetection = null;
    let camera = null;

    // Persistent mask system - works at lower resolution for speed
    const MASK_WIDTH = 320;
    const MASK_HEIGHT = 180;
    let persistentMask = null;
    let previousFrameData = null;
    let primaryFaceBox = null;

    // Tuning parameters
    const MASK_STRENGTHEN_RATE = 0.3;  // How fast to strengthen mask in face region
    const MASK_DECAY_RATE = 0.02;      // How fast mask decays (allows adaptation)
    const MOTION_THRESHOLD = 15;       // Sensitivity to motion
    const FACE_REGION_SCALE = 3.5;     // How much to expand face bbox for body

    function addDebug(msg) {
      const timestamp = new Date().toLocaleTimeString();
      debugLog.innerHTML += `[${timestamp}] ${msg}<br>`;
      debugLog.scrollTop = debugLog.scrollHeight;
      console.log(msg);
    }

    function showToast(message, type = 'info') {
      const toast = document.createElement('div');
      toast.className = `toast ${type}`;
      toast.innerHTML = `
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <circle cx="12" cy="12" r="10"/>
          <line x1="12" y1="8" x2="12" y2="12"/>
          <line x1="12" y1="16" x2="12.01" y2="16"/>
        </svg>
        <span class="toast-message">${message}</span>
      `;
      toastContainer.appendChild(toast);
      setTimeout(() => toast.remove(), 5000);
    }

    async function startCamera() {
      startBtn.disabled = true;
      btnText.textContent = 'Initializing...';
      addDebug('Requesting camera access...');

      try {
        const stream = await navigator.mediaDevices.getUserMedia({
          video: { width: 1280, height: 720, facingMode: 'user' },
          audio: false
        });

        video.srcObject = stream;
        await video.play();

        isStarted = true;
        placeholder.classList.add('hidden');
        btnText.textContent = 'Camera Active';
        bgToggle.classList.remove('disabled');
        addDebug('✓ Camera started successfully');
      } catch (err) {
        addDebug(`Camera error: ${err.message}`);
        showToast('Failed to access camera', 'error');
        startBtn.disabled = false;
        btnText.textContent = 'Start Camera';
      }
    }

    async function initializeMediaPipe() {
      addDebug('Initializing MediaPipe Selfie Segmentation...');

      try {
        // Initialize selfie segmentation
        selfieSegmentation = new SelfieSegmentation({
          locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/${file}`
        });

        selfieSegmentation.setOptions({
          modelSelection: 1,
          selfieMode: false,
        });

        selfieSegmentation.onResults(onSegmentationResults);

        // Initialize face detection
        faceDetection = new FaceDetection({
          locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_detection/${file}`
        });

        faceDetection.setOptions({
          model: 'short',
          minDetectionConfidence: 0.5
        });

        faceDetection.onResults(onFaceResults);

        // Initialize persistent mask
        persistentMask = new Float32Array(MASK_WIDTH * MASK_HEIGHT);

        // Start camera feed
        camera = new Camera(video, {
          onFrame: async () => {
            if (virtualBgEnabled && selfieSegmentation) {
              await Promise.all([
                selfieSegmentation.send({ image: video }),
                faceDetection.send({ image: video })
              ]);
            }
          },
          width: 1280,
          height: 720
        });

        await camera.start();
        addDebug('✓ MediaPipe initialized successfully');
        addDebug('✓ Face detection active');
        addDebug('✓ Persistent mask system ready');
      } catch (err) {
        addDebug(`MediaPipe initialization failed: ${err.message}`);
        showToast('Virtual background unavailable', 'warning');
      }
    }

    function onFaceResults(results) {
      if (!results.detections || results.detections.length === 0) {
        primaryFaceBox = null;
        return;
      }

      // Pick primary face (largest and most central)
      const videoW = video.videoWidth;
      const videoH = video.videoHeight;
      const centerX = videoW / 2;
      const centerY = videoH / 2;

      let bestFace = null;
      let bestScore = -1;

      for (const detection of results.detections) {
        const box = detection.boundingBox;
        const fx = box.xCenter * videoW;
        const fy = box.yCenter * videoH;
        const fw = box.width * videoW;
        const fh = box.height * videoH;

        const distFromCenter = Math.sqrt(
          Math.pow(fx - centerX, 2) +
          Math.pow(fy - centerY, 2)
        );

        const area = fw * fh;
        const score = area / (1 + distFromCenter * 0.001);

        if (score > bestScore) {
          bestScore = score;
          bestFace = { x: fx, y: fy, width: fw, height: fh };
        }
      }

      primaryFaceBox = bestFace;

      // Alert if multiple faces
      if (results.detections.length > 1 && Math.random() < 0.05) {
        addDebug(`⚠️ ${results.detections.length} faces detected`);
      }
    }

    function detectMotion(currentFrameData) {
      if (!previousFrameData) {
        previousFrameData = new Uint8ClampedArray(currentFrameData);
        return new Uint8Array(MASK_WIDTH * MASK_HEIGHT);
      }

      const motionMask = new Uint8Array(MASK_WIDTH * MASK_HEIGHT);

      for (let i = 0; i < currentFrameData.length; i += 4) {
        const idx = i / 4;
        const r = Math.abs(currentFrameData[i] - previousFrameData[i]);
        const g = Math.abs(currentFrameData[i + 1] - previousFrameData[i + 1]);
        const b = Math.abs(currentFrameData[i + 2] - previousFrameData[i + 2]);
        const diff = (r + g + b) / 3;

        motionMask[idx] = diff > MOTION_THRESHOLD ? 1 : 0;
      }

      previousFrameData = new Uint8ClampedArray(currentFrameData);
      return motionMask;
    }

    function updatePersistentMask(segmentationMask, motionMask) {
      // Decay the persistent mask slightly (allows adaptation over time)
      for (let i = 0; i < persistentMask.length; i++) {
        persistentMask[i] *= (1 - MASK_DECAY_RATE);
      }

      // If we have a face, strengthen mask in the face region
      if (primaryFaceBox) {
        const scaleX = MASK_WIDTH / video.videoWidth;
        const scaleY = MASK_HEIGHT / video.videoHeight;

        // Expand face box to include head + upper body
        const expandedHeight = primaryFaceBox.height * FACE_REGION_SCALE;
        const expandedWidth = primaryFaceBox.width * 1.8;

        const regionX = Math.max(0, (primaryFaceBox.x - expandedWidth / 2) * scaleX);
        const regionY = Math.max(0, (primaryFaceBox.y - primaryFaceBox.height * 0.5) * scaleY);
        const regionW = Math.min(MASK_WIDTH - regionX, expandedWidth * scaleX);
        const regionH = Math.min(MASK_HEIGHT - regionY, expandedHeight * scaleY);

        // Strengthen mask in face region where segmentation shows person
        for (let y = Math.floor(regionY); y < Math.floor(regionY + regionH); y++) {
          for (let x = Math.floor(regionX); x < Math.floor(regionX + regionW); x++) {
            const idx = y * MASK_WIDTH + x;
            if (idx >= 0 && idx < persistentMask.length) {
              // If segmentation says "person" in this region, strengthen
              if (segmentationMask[idx] > 128) {
                persistentMask[idx] = Math.min(1.0, persistentMask[idx] + MASK_STRENGTHEN_RATE);
              }
            }
          }
        }
      }

      // If motion is detected outside the persistent mask, ensure it stays suppressed
      for (let i = 0; i < persistentMask.length; i++) {
        if (motionMask[i] === 1 && persistentMask[i] < 0.3) {
          // New motion outside primary person - keep it suppressed
          persistentMask[i] = 0;
        }
      }
    }

    function applyPersistentMask(frameData, segmentationMask) {
      // Create low-res versions
      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = MASK_WIDTH;
      tempCanvas.height = MASK_HEIGHT;
      const tempCtx = tempCanvas.getContext('2d');

      // Downsample video frame for motion detection
      tempCtx.drawImage(video, 0, 0, MASK_WIDTH, MASK_HEIGHT);
      const lowResFrame = tempCtx.getImageData(0, 0, MASK_WIDTH, MASK_HEIGHT);

      // Downsample segmentation mask
      tempCtx.clearRect(0, 0, MASK_WIDTH, MASK_HEIGHT);
      const maskCanvas = document.createElement('canvas');
      maskCanvas.width = segmentationMask.width;
      maskCanvas.height = segmentationMask.height;
      const maskCtx = maskCanvas.getContext('2d');
      maskCtx.putImageData(segmentationMask, 0, 0);
      tempCtx.drawImage(maskCanvas, 0, 0, MASK_WIDTH, MASK_HEIGHT);
      const lowResMask = tempCtx.getImageData(0, 0, MASK_WIDTH, MASK_HEIGHT);

      // Detect motion
      const motionMask = detectMotion(lowResFrame.data);

      // Update persistent mask
      updatePersistentMask(lowResMask.data, motionMask);

      // Apply persistent mask to full resolution frame
      const scaleX = frameData.width / MASK_WIDTH;
      const scaleY = frameData.height / MASK_HEIGHT;

      for (let y = 0; y < frameData.height; y++) {
        for (let x = 0; x < frameData.width; x++) {
          const fullIdx = (y * frameData.width + x) * 4;

          // Map to low-res persistent mask
          const lowX = Math.floor(x / scaleX);
          const lowY = Math.floor(y / scaleY);
          const lowIdx = lowY * MASK_WIDTH + lowX;

          // Apply persistent mask with feathering
          const maskValue = persistentMask[lowIdx];

          if (maskValue < 0.1) {
            // Strong suppression - make transparent
            frameData.data[fullIdx + 3] = 0;
          } else if (maskValue < 0.5) {
            // Partial suppression - fade out
            frameData.data[fullIdx + 3] *= maskValue;
          }
          // else: maskValue >= 0.5, keep fully visible
        }
      }
    }

    function onSegmentationResults(results) {
      if (!virtualBgEnabled) return;

      const ctx = canvas.getContext('2d');
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;

      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = '#1e3a8a';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      if (!results.segmentationMask) {
        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
        return;
      }

      // Get segmentation mask
      const maskCanvas = document.createElement('canvas');
      maskCanvas.width = canvas.width;
      maskCanvas.height = canvas.height;
      const maskCtx = maskCanvas.getContext('2d');
      maskCtx.drawImage(results.segmentationMask, 0, 0, maskCanvas.width, maskCanvas.height);
      const maskData = maskCtx.getImageData(0, 0, maskCanvas.width, maskCanvas.height);

      // Get video frame
      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = canvas.width;
      tempCanvas.height = canvas.height;
      const tempCtx = tempCanvas.getContext('2d');
      tempCtx.drawImage(video, 0, 0, tempCanvas.width, tempCanvas.height);
      const frameData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);

      if (ghostModeEnabled) {
        // Use persistent mask system
        applyPersistentMask(frameData, maskData);
      } else {
        // Standard mode - just apply segmentation
        for (let i = 0; i < frameData.data.length; i += 4) {
          if (maskData.data[i] < 128) {
            frameData.data[i + 3] = 0;
          }
        }
      }

      tempCtx.putImageData(frameData, 0, 0);
      ctx.drawImage(tempCanvas, 0, 0);
    }

    async function toggleVirtualBackground() {
      if (!isStarted) return;

      if (!virtualBgEnabled && !selfieSegmentation) {
        await initializeMediaPipe();
      }

      virtualBgEnabled = !virtualBgEnabled;
      bgToggle.classList.toggle('active', virtualBgEnabled);

      if (virtualBgEnabled) {
        video.classList.add('hidden');
        canvas.classList.remove('hidden');
        ghostToggle.classList.remove('disabled');
        addDebug('Virtual background enabled');
      } else {
        video.classList.remove('hidden');
        canvas.classList.add('hidden');
        ghostToggle.classList.add('disabled');
        ghostToggle.classList.remove('active');
        ghostModeEnabled = false;
        infoBox.classList.add('hidden');
        addDebug('Virtual background disabled');
      }
    }

    function toggleGhostMode() {
      if (!isStarted || !virtualBgEnabled) return;

      ghostModeEnabled = !ghostModeEnabled;
      ghostToggle.classList.toggle('active', ghostModeEnabled);
      infoBox.classList.toggle('hidden', !ghostModeEnabled);

      if (ghostModeEnabled) {
        // Reset persistent mask
        persistentMask.fill(0);
        previousFrameData = null;
        addDebug('Ghost mode enabled - persistent mask active');
        addDebug('Tracking primary person with face-anchored mask');
      } else {
        addDebug('Ghost mode disabled');
      }
    }

    startBtn.addEventListener('click', startCamera);
    bgToggle.addEventListener('click', toggleVirtualBackground);
    ghostToggle.addEventListener('click', toggleGhostMode);

    window.addEventListener('load', () => {
      addDebug('Checking browser support...');
      if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
        addDebug('✓ Camera API supported');
        startBtn.disabled = false;
      } else {
        addDebug('ERROR: Camera API not supported');
        showToast('Browser does not support camera access', 'error');
      }
    });

    window.addEventListener('beforeunload', () => {
      if (camera) camera.stop();
      if (video.srcObject) {
        video.srcObject.getTracks().forEach(track => track.stop());
      }
    });
  </script>
</body>
</html>
