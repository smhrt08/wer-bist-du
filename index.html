<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>wer bist du</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
      min-height: 100vh;
      padding: 2rem;
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
    }

    .header {
      text-align: center;
      margin-bottom: 2rem;
    }

    .header h1 {
      font-size: 2.5rem;
      color: #1e293b;
      margin-bottom: 0.5rem;
      font-weight: 700;
    }

    .header p {
      color: #64748b;
      font-size: 1.1rem;
      margin-bottom: 1.5rem;
    }

    .btn-primary {
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.75rem 1.5rem;
      background: #2563eb;
      color: white;
      border: none;
      border-radius: 0.5rem;
      font-size: 1rem;
      font-weight: 500;
      cursor: pointer;
      transition: background 0.3s;
    }

    .btn-primary:hover:not(:disabled) {
      background: #1d4ed8;
    }

    .btn-primary:disabled {
      background: #cbd5e1;
      cursor: not-allowed;
    }

    .main-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 2rem;
      margin-top: 2rem;
    }

    .card {
      background: white;
      border-radius: 1rem;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      padding: 1.5rem;
    }

    .video-container {
      position: relative;
      aspect-ratio: 16/9;
      background: #0f172a;
      border-radius: 0.75rem;
      overflow: hidden;
      margin-bottom: 1rem;
    }

    video, canvas {
      width: 100%;
      height: 100%;
      object-fit: contain;
    }

    .video-placeholder {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #94a3b8;
    }

    .controls {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    .control-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0.75rem;
      background: #f8fafc;
      border-radius: 0.5rem;
    }

    .control-label {
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
    }

    .control-label span {
      font-size: 0.875rem;
      font-weight: 500;
      color: #334155;
    }

    .control-label small {
      font-size: 0.75rem;
      color: #64748b;
    }

    .toggle {
      position: relative;
      width: 3.5rem;
      height: 2rem;
      background: #cbd5e1;
      border-radius: 1rem;
      cursor: pointer;
      transition: background 0.3s;
    }

    .toggle.active {
      background: #2563eb;
    }

    .toggle.disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .toggle-slider {
      position: absolute;
      top: 0.25rem;
      left: 0.25rem;
      width: 1.5rem;
      height: 1.5rem;
      background: white;
      border-radius: 50%;
      transition: transform 0.3s;
    }

    .toggle.active .toggle-slider {
      transform: translateX(1.5rem);
    }

    .info-box {
      margin-top: 1rem;
      padding: 0.75rem;
      background: #dbeafe;
      border: 1px solid #93c5fd;
      border-radius: 0.5rem;
    }

    .info-box p {
      font-size: 0.875rem;
      color: #1e40af;
      line-height: 1.5;
    }

    .debug-panel h2 {
      font-size: 1.125rem;
      font-weight: 600;
      color: #1e293b;
      margin-bottom: 1rem;
    }

    .debug-log {
      height: 24rem;
      overflow-y: auto;
      background: #f8fafc;
      border: 1px solid #e2e8f0;
      border-radius: 0.5rem;
      padding: 1rem;
      font-family: 'Courier New', monospace;
      font-size: 0.75rem;
      color: #334155;
    }

    .toast-container {
      position: fixed;
      bottom: 2rem;
      right: 2rem;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      z-index: 1000;
    }

    .toast {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      padding: 0.75rem 1rem;
      background: white;
      border-radius: 0.5rem;
      box-shadow: 0 10px 15px rgba(0, 0, 0, 0.1);
      border-left: 4px solid;
      animation: slideIn 0.3s ease-out;
    }

    .toast.error { border-color: #dc2626; color: #991b1b; }
    .toast.warning { border-color: #f59e0b; color: #92400e; }
    .toast.info { border-color: #2563eb; color: #1e40af; }

    .toast-message {
      font-size: 0.875rem;
      font-weight: 500;
    }

    @keyframes slideIn {
      from {
        transform: translateX(100%);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }

    .hidden { display: none; }

    @media (max-width: 768px) {
      body { padding: 1rem; }
      .main-grid {
        grid-template-columns: 1fr;
        gap: 1rem;
      }
      .header h1 { font-size: 1.75rem; }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>wer bist du</h1>
      <p>v6.006</p>
      <button id="startBtn" class="btn-primary" disabled>
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"/>
          <circle cx="12" cy="13" r="4"/>
        </svg>
        <span id="btnText">Start Camera</span>
      </button>
    </div>

    <div class="main-grid">
      <div class="card">
        <div class="video-container">
          <video id="video" autoplay muted playsinline></video>
          <canvas id="canvas" class="hidden"></canvas>
          <div id="placeholder" class="video-placeholder">
            <svg width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"/>
              <circle cx="12" cy="13" r="4"/>
            </svg>
          </div>
        </div>

        <div class="controls">
          <div class="control-row">
            <span class="control-label">
              <span>Virtual Background</span>
            </span>
            <div id="bgToggle" class="toggle disabled">
              <div class="toggle-slider"></div>
            </div>
          </div>

          <div class="control-row">
            <div class="control-label">
              <span>Ghost Mode</span>
              <small>Aggressive background suppression</small>
            </div>
            <div id="ghostToggle" class="toggle disabled">
              <div class="toggle-slider"></div>
            </div>
          </div>
        </div>

        <div id="infoBox" class="info-box hidden">
          <p><strong>Ghost Mode Active:</strong> Persistent mask tracks primary person. All background movement (pets, people, objects) is aggressively hidden even when connected.</p>
        </div>
      </div>

      <div class="card debug-panel">
        <h2>Debug Log</h2>
        <div id="debugLog" class="debug-log"></div>
      </div>
    </div>
  </div>

  <div id="toastContainer" class="toast-container"></div>

  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/selfie_segmentation.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_detection/face_detection.js"></script>

  <script>
    const video = document.getElementById('video');
    const canvas = document.getElementById('canvas');
    const placeholder = document.getElementById('placeholder');
    const startBtn = document.getElementById('startBtn');
    const btnText = document.getElementById('btnText');
    const bgToggle = document.getElementById('bgToggle');
    const ghostToggle = document.getElementById('ghostToggle');
    const infoBox = document.getElementById('infoBox');
    const debugLog = document.getElementById('debugLog');
    const toastContainer = document.getElementById('toastContainer');

    let isStarted = false;
    let virtualBgEnabled = false;
    let ghostModeEnabled = false;
    let selfieSegmentation = null;
    let faceDetection = null;
    let camera = null;

    // Persistent mask system - works at lower resolution for speed
    const MASK_WIDTH = 320;
    const MASK_HEIGHT = 180;
    let persistentMask = null;
    let shapeMask = null;  // NEW: Defines valid person region
    let previousFrameData = null;
    let primaryFaceBox = null;
    
    // Tuning parameters
    const MASK_STRENGTHEN_RATE = 0.4;  // Faster strengthening
    const MASK_DECAY_RATE = 0.015;     // Slower decay
    const MOTION_THRESHOLD = 12;       // Motion sensitivity
    const FACE_REGION_SCALE = 3.5;     // Body region size
    const SHAPE_CONSTRAINT_STRENGTH = 0.9;  // How strictly to enforce shape
    const EDGE_SUPPRESSION = 0.7;      // Suppress edges more aggressively

    function addDebug(msg) {
      const timestamp = new Date().toLocaleTimeString();
      debugLog.innerHTML += `[${timestamp}] ${msg}<br>`;
      debugLog.scrollTop = debugLog.scrollHeight;
      console.log(msg);
    }

    function showToast(message, type = 'info') {
      const toast = document.createElement('div');
      toast.className = `toast ${type}`;
      toast.innerHTML = `
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <circle cx="12" cy="12" r="10"/>
          <line x1="12" y1="8" x2="12" y2="12"/>
          <line x1="12" y1="16" x2="12.01" y2="16"/>
        </svg>
        <span class="toast-message">${message}</span>
      `;
      toastContainer.appendChild(toast);
      setTimeout(() => toast.remove(), 5000);
    }

    async function startCamera() {
      startBtn.disabled = true;
      btnText.textContent = 'Initializing...';
      addDebug('Requesting camera access...');

      try {
        const stream = await navigator.mediaDevices.getUserMedia({
          video: { width: 1280, height: 720, facingMode: 'user' },
          audio: false
        });

        video.srcObject = stream;
        await video.play();

        isStarted = true;
        placeholder.classList.add('hidden');
        btnText.textContent = 'Camera Active';
        bgToggle.classList.remove('disabled');
        addDebug('✓ Camera started successfully');
      } catch (err) {
        addDebug(`Camera error: ${err.message}`);
        showToast('Failed to access camera', 'error');
        startBtn.disabled = false;
        btnText.textContent = 'Start Camera';
      }
    }

    async function initializeMediaPipe() {
      addDebug('Initializing MediaPipe Selfie Segmentation...');
    
      try {
        // Initialize selfie segmentation
        selfieSegmentation = new SelfieSegmentation({
          locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/${file}`
        });
    
        selfieSegmentation.setOptions({
          modelSelection: 1,
          selfieMode: false,
        });
    
        selfieSegmentation.onResults(onSegmentationResults);
    
        // Initialize face detection
        faceDetection = new FaceDetection({
          locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_detection/${file}`
        });
    
        faceDetection.setOptions({
          model: 'short',
          minDetectionConfidence: 0.5
        });
    
        faceDetection.onResults(onFaceResults);
    
        // Initialize persistent mask
        persistentMask = new Float32Array(MASK_WIDTH * MASK_HEIGHT);
    
        // Start camera feed
        camera = new Camera(video, {
          onFrame: async () => {
            if (virtualBgEnabled) {
              if (ghostModeEnabled && selfieSegmentation) {
                // Ghost mode - use MediaPipe
                await Promise.all([
                  selfieSegmentation.send({ image: video }),
                  faceDetection.send({ image: video })
                ]);
              } else {
                // Virtual background without ghost mode - just draw video with background
                const ctx = canvas.getContext('2d');
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#1e3a8a';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
              }
            }
          },
          width: 1280,
          height: 720
        });
    
        await camera.start();
        addDebug('✓ MediaPipe initialized successfully');
        addDebug('✓ Face detection active');
        addDebug('✓ Persistent mask system ready');
      } catch (err) {
        addDebug(`MediaPipe initialization failed: ${err.message}`);
        showToast('Virtual background unavailable', 'warning');
      }
    }

    function onFaceResults(results) {
      if (!results.detections || results.detections.length === 0) {
        primaryFaceBox = null;
        return;
      }

      // Pick primary face (largest and most central)
      const videoW = video.videoWidth;
      const videoH = video.videoHeight;
      const centerX = videoW / 2;
      const centerY = videoH / 2;

      let bestFace = null;
      let bestScore = -1;

      for (const detection of results.detections) {
        const box = detection.boundingBox;
        const fx = box.xCenter * videoW;
        const fy = box.yCenter * videoH;
        const fw = box.width * videoW;
        const fh = box.height * videoH;

        const distFromCenter = Math.sqrt(
          Math.pow(fx - centerX, 2) +
          Math.pow(fy - centerY, 2)
        );

        const area = fw * fh;
        const score = area / (1 + distFromCenter * 0.001);

        if (score > bestScore) {
          bestScore = score;
          bestFace = { x: fx, y: fy, width: fw, height: fh };
        }
      }

      primaryFaceBox = bestFace;

      // Alert if multiple faces
      if (results.detections.length > 1 && Math.random() < 0.05) {
        addDebug(`⚠️ ${results.detections.length} faces detected`);
      }
    }

    function detectMotion(currentFrameData) {
      if (!previousFrameData) {
        previousFrameData = new Uint8ClampedArray(currentFrameData);
        return new Uint8Array(MASK_WIDTH * MASK_HEIGHT);
      }

      const motionMask = new Uint8Array(MASK_WIDTH * MASK_HEIGHT);

      for (let i = 0; i < currentFrameData.length; i += 4) {
        const idx = i / 4;
        const r = Math.abs(currentFrameData[i] - previousFrameData[i]);
        const g = Math.abs(currentFrameData[i + 1] - previousFrameData[i + 1]);
        const b = Math.abs(currentFrameData[i + 2] - previousFrameData[i + 2]);
        const diff = (r + g + b) / 3;

        motionMask[idx] = diff > MOTION_THRESHOLD ? 1 : 0;
      }

      previousFrameData = new Uint8ClampedArray(currentFrameData);
      return motionMask;
    }

    function updatePersistentMask(segmentationMask, motionMask) {
      // Decay the persistent mask slightly
      for (let i = 0; i < persistentMask.length; i++) {
        persistentMask[i] *= (1 - MASK_DECAY_RATE);
      }
    
      // Build/update shape mask based on face position
      if (primaryFaceBox) {
        const scaleX = MASK_WIDTH / video.videoWidth;
        const scaleY = MASK_HEIGHT / video.videoHeight;
    
        // Define the valid person region (head + upper body)
        const expandedHeight = primaryFaceBox.height * FACE_REGION_SCALE;
        const expandedWidth = primaryFaceBox.width * 1.8;
    
        const centerX = primaryFaceBox.x * scaleX;
        const centerY = (primaryFaceBox.y - primaryFaceBox.height * 0.5) * scaleY;
        
        const regionX = Math.max(0, centerX - (expandedWidth * scaleX) / 2);
        const regionY = Math.max(0, centerY);
        const regionW = Math.min(MASK_WIDTH - regionX, expandedWidth * scaleX);
        const regionH = Math.min(MASK_HEIGHT - regionY, expandedHeight * scaleY);
    
        // Initialize or update shape mask
        if (!shapeMask) {
          shapeMask = new Float32Array(MASK_WIDTH * MASK_HEIGHT);
        }
    
        // Create elliptical shape mask centered on face
        const ellipseCenterX = centerX;
        const ellipseCenterY = centerY + (expandedHeight * scaleY) / 3; // Slightly below face
        const ellipseRadiusX = (expandedWidth * scaleX) / 2;
        const ellipseRadiusY = (expandedHeight * scaleY) / 2;
    
        for (let y = 0; y < MASK_HEIGHT; y++) {
          for (let x = 0; x < MASK_WIDTH; x++) {
            const idx = y * MASK_WIDTH + x;
            
            // Calculate distance from ellipse center (normalized)
            const dx = (x - ellipseCenterX) / ellipseRadiusX;
            const dy = (y - ellipseCenterY) / ellipseRadiusY;
            const distFromCenter = Math.sqrt(dx * dx + dy * dy);
            
            // Smooth falloff: 1.0 at center, 0.0 outside ellipse
            const shapeValue = Math.max(0, Math.min(1, 1.2 - distFromCenter));
            
            // Blend with existing shape mask (allows gradual adaptation)
            shapeMask[idx] = shapeMask[idx] * 0.95 + shapeValue * 0.05;
          }
        }
    
        // Strengthen mask ONLY within the shape constraint
        for (let y = Math.floor(regionY); y < Math.floor(regionY + regionH); y++) {
          for (let x = Math.floor(regionX); x < Math.floor(regionX + regionW); x++) {
            const idx = y * MASK_WIDTH + x;
            if (idx >= 0 && idx < persistentMask.length) {
              // Only strengthen if:
              // 1. Segmentation says "person"
              // 2. Within valid shape region
              if (segmentationMask[idx] > 128 && shapeMask[idx] > 0.3) {
                const strengthenAmount = MASK_STRENGTHEN_RATE * shapeMask[idx];
                persistentMask[idx] = Math.min(1.0, persistentMask[idx] + strengthenAmount);
              }
            }
          }
        }
      }
    
      // AGGRESSIVE SUPPRESSION: Any motion outside the shape mask is background
      for (let i = 0; i < persistentMask.length; i++) {
        if (motionMask[i] === 1) {
          // Motion detected
          const shapeStrength = shapeMask ? shapeMask[i] : 0;
          
          if (shapeStrength < 0.3) {
            // Motion outside valid person shape - SUPPRESS HARD
            persistentMask[i] = 0;
          } else if (shapeStrength < 0.6) {
            // Motion at edge of person shape - suppress moderately
            persistentMask[i] *= EDGE_SUPPRESSION;
          }
          // else: Motion within core person shape - allow it
        }
      }
    }

   function applyPersistentMask(frameData, segmentationMask) {
  // Create low-res versions
  const tempCanvas = document.createElement('canvas');
  tempCanvas.width = MASK_WIDTH;
  tempCanvas.height = MASK_HEIGHT;
  const tempCtx = tempCanvas.getContext('2d');

  // Downsample video frame for motion detection
  tempCtx.drawImage(video, 0, 0, MASK_WIDTH, MASK_HEIGHT);
  const lowResFrame = tempCtx.getImageData(0, 0, MASK_WIDTH, MASK_HEIGHT);

  // Downsample segmentation mask
  tempCtx.clearRect(0, 0, MASK_WIDTH, MASK_HEIGHT);
  const maskCanvas = document.createElement('canvas');
  maskCanvas.width = segmentationMask.width;
  maskCanvas.height = segmentationMask.height;
  const maskCtx = maskCanvas.getContext('2d');
  maskCtx.putImageData(segmentationMask, 0, 0);
  tempCtx.drawImage(maskCanvas, 0, 0, MASK_WIDTH, MASK_HEIGHT);
  const lowResMask = tempCtx.getImageData(0, 0, MASK_WIDTH, MASK_HEIGHT);

  // Detect motion
  const motionMask = detectMotion(lowResFrame.data);

  // Update persistent mask with shape constraints
  updatePersistentMask(lowResMask.data, motionMask);

  // Apply persistent mask to full resolution frame
  const scaleX = frameData.width / MASK_WIDTH;
  const scaleY = frameData.height / MASK_HEIGHT;

  for (let y = 0; y < frameData.height; y++) {
    for (let x = 0; x < frameData.width; x++) {
      const fullIdx = (y * frameData.width + x) * 4;

      // Map to low-res persistent mask
      const lowX = Math.floor(x / scaleX);
      const lowY = Math.floor(y / scaleY);
      const lowIdx = lowY * MASK_WIDTH + lowX;

      // Get both mask values
      const maskValue = persistentMask[lowIdx];
      const shapeValue = shapeMask ? shapeMask[lowIdx] : 1.0;

      // Combine: only show pixels that pass BOTH tests
      const finalMask = maskValue * (0.3 + 0.7 * shapeValue);

      if (finalMask < 0.15) {
        // Strong suppression
        frameData.data[fullIdx + 3] = 0;
      } else if (finalMask < 0.5) {
        // Partial suppression with feathering
        frameData.data[fullIdx + 3] *= finalMask * 2;
      }
      // else: Keep fully visible
    }
  }
}

    function onSegmentationResults(results) {
      if (!virtualBgEnabled || !ghostModeEnabled) return;
    
      const ctx = canvas.getContext('2d');
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
    
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = '#1e3a8a';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    
      if (!results.segmentationMask) {
        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
        return;
      }
    
      // Get segmentation mask
      const maskCanvas = document.createElement('canvas');
      maskCanvas.width = canvas.width;
      maskCanvas.height = canvas.height;
      const maskCtx = maskCanvas.getContext('2d');
      maskCtx.drawImage(results.segmentationMask, 0, 0, maskCanvas.width, maskCanvas.height);
      const maskData = maskCtx.getImageData(0, 0, maskCanvas.width, maskCanvas.height);
    
      // Get video frame
      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = canvas.width;
      tempCanvas.height = canvas.height;
      const tempCtx = tempCanvas.getContext('2d');
      tempCtx.drawImage(video, 0, 0, tempCanvas.width, tempCanvas.height);
      const frameData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
    
      // Use persistent mask system
      applyPersistentMask(frameData, maskData);
    
      tempCtx.putImageData(frameData, 0, 0);
      ctx.drawImage(tempCanvas, 0, 0);
    }

    async function toggleVirtualBackground() {
      if (!isStarted) return;

      if (!virtualBgEnabled && !selfieSegmentation) {
        await initializeMediaPipe();
      }

      virtualBgEnabled = !virtualBgEnabled;
      bgToggle.classList.toggle('active', virtualBgEnabled);

      if (virtualBgEnabled) {
        video.classList.add('hidden');
        canvas.classList.remove('hidden');
        ghostToggle.classList.remove('disabled');
        addDebug('Virtual background enabled');
      } else {
        video.classList.remove('hidden');
        canvas.classList.add('hidden');
        ghostToggle.classList.add('disabled');
        ghostToggle.classList.remove('active');
        ghostModeEnabled = false;
        infoBox.classList.add('hidden');
        addDebug('Virtual background disabled');
      }
    }

    function toggleGhostMode() {
  if (!isStarted || !virtualBgEnabled) return;

  ghostModeEnabled = !ghostModeEnabled;
  ghostToggle.classList.toggle('active', ghostModeEnabled);
  infoBox.classList.toggle('hidden', !ghostModeEnabled);

  if (ghostModeEnabled) {
    // Reset persistent mask and shape mask
    persistentMask.fill(0);
    shapeMask = null;  // Will be rebuilt based on face
    previousFrameData = null;
    addDebug('Ghost mode enabled - shape-constrained mask active');
    addDebug('Building anatomical shape model from face detection');
  } else {
    addDebug('Ghost mode disabled');
  }
}
    startBtn.addEventListener('click', startCamera);
    bgToggle.addEventListener('click', toggleVirtualBackground);
    ghostToggle.addEventListener('click', toggleGhostMode);

    window.addEventListener('load', () => {
      addDebug('Checking browser support...');
      if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
        addDebug('✓ Camera API supported');
        startBtn.disabled = false;
      } else {
        addDebug('ERROR: Camera API not supported');
        showToast('Browser does not support camera access', 'error');
      }
    });

    window.addEventListener('beforeunload', () => {
      if (camera) camera.stop();
      if (video.srcObject) {
        video.srcObject.getTracks().forEach(track => track.stop());
      }
    });
  </script>
</body>
</html>
